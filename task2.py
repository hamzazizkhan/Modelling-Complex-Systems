import random
import itertools
import numpy as np

# the function below returns the number of graphs with isolated components
# it takes graphs - number of graphs, n_size - the number of vertices/nodes.
# it returns the number of graphs with isolated components.
# a function that returns the number of graphs with NO isolated components is given on line 52.

def G(graphs, n_size):
    isolated_componenets = 0
    # n stores the nodes in a list
    n = [i for i in range(n_size)]

    for i in range(graphs):
        # p generates a p < ln(n)/n
        p = random.uniform(0, (np.log(n_size) / n_size)-0.0001)
        # nodes_with_edges stores the nodes with edges
        nodes_with_edges = []
        # loop through all possible edges generated by itertools.combinations
        for i in itertools.combinations(n, 2):
            # the if statement below gives a arandom probability to each edge
            # if that probability is less than p, the nodes in the edges are stored in nodes_with_edges
            if random.random() < p:
                #print(i)
                if i[0] not in nodes_with_edges:
                    nodes_with_edges.append(i[0])
                if i[1] not in nodes_with_edges:
                    nodes_with_edges.append(i[1])

        # this if statement checks for isolated components; These are nodes with no edges
        if len(n) - len(nodes_with_edges) > 0:
            # if the graph has an isolated component,  1 is added to isolated_componenets
            isolated_componenets += 1
    # return the number of graphs with isolated components.
    return isolated_componenets

graphs = 30
n_size = 1000
isolated_componenets = G(graphs,n_size)
#print(f"out of {graphs} grpahs {isolated_componenets} had isolated componenets for p < ln(n)/n:")
print(f"out of {graphs} grpahs {isolated_componenets} had no isolated componenets for p > ln(n)/n:")

# n is 100: result: out of 20 grpahs 20 had isolated componenets for p < ln(n)/n:
# n is 1000: result: out of 50 grpahs 50 had isolated componenets for p < ln(n)/n:

# n is 100: result: out of 20 grpahs 20 had no isolated componenets for p > ln(n)/n:

# change p and if statement for different cases.

'''
only minor changes to the G function for p> ln(n)/n are required (line 61 and line 72)
def G(graphs, n_size):
    isolated_componenets = 0
    # n stores the nodes in a list
    n = [i for i in range(n_size)]

    for i in range(graphs):
        
        # CHANGE HERE
        p = random.uniform((np.log(n_size) / n_size)+0.0001, 1)
        nodes_with_edges = []
        for i in itertools.combinations(n, 2):
            if random.random() < p:
                #print(i)
                if i[0] not in nodes_with_edges:
                    nodes_with_edges.append(i[0])
                if i[1] not in nodes_with_edges:
                    nodes_with_edges.append(i[1])

        # CHANGE HERE
        if len(n) - len(nodes_with_edges) == 0:
            isolated_componenets += 1

    return isolated_componenets

'''


